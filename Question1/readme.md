## 代码运行环境
* 开发环境,Python 3.5.1
* 测试环境, 3.2,3.3,3.4,3.5
* Python 2.7因为不支持function annotations,就先不兼容了
## 问题分析
### 现状
这是一棵树状结构的组织列表,从数据定义看,可以向下搜索,但没有向上找父类节点的能力
### 问题
* 通过对给出的case进行判断,寻找两个节点的共同父类
* 指定两个节点上,如果一个节点是另一个节点的父类则直接返回父类节点

### 化简
用列表来描述路径,枚举出从根到每个节点的路径,然后挑出到指定2个节点的路径列表,比较这两个路径列表的最大共同子串,给出子串的end值

### 特殊情况
当有的雇员在ceo的管辖范围之外,比如给的ceo是"副ceo",则会抛出一个指定某个雇员不在ceo管辖范围的ValueError异常
当两个雇员相同时,会抛出比较雇员相同的异常
当ceo和某个雇员相同时,则得到的结果是ceo
当ceo和某个不在管辖范围的员工比较时,得到的是某个雇员不在ceo管辖范围的ValueError异常

## 进阶
进阶代码在advance中,对题目中给的代码结构进行了稍微的修正,以符合现在的代码命名潮流.
### 改进
* 可以不枚举完所有的路径,找到两个指定路径就返回,但这和下面这种优化冲突
* 用动态规划的思想,把遍历完的路径保存在一个数据结构中,这样下次只需要直接调用遍历路径即可
* advance中采用方法二进行优化
* 测试cpu,2.6GHz, Intel Core i5, 机型MBP(Mid 2014)
* 测试10000次跑样本数据,优化后的运行耗时在115~120 ms,优化前在840~950 ms
* 1 seconds = 1000 ms

### 代码规范
* 根据Python的PEP8,函数名应该都小写

### 单元测试
* 单元测试很重要
* 上述讨论均在单元测试中有所体现
